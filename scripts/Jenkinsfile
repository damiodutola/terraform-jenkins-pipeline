// Jenkinsfile â€” Terraform IaC with env + action params and approvals
// Repo layout (example):
//   /infra/                 -> Terraform root
//     main.tf
//     versions.tf
//     variables.tf
//     backend.hcl           -> backend config (optional)
//     vars/
//       dev.tfvars
//       qa.tfvars
//       prod.tfvars

pipeline {
  agent any

  options {
    // Avoid mixing runs; also lock per env later for job-level safety
    disableConcurrentBuilds()
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '25'))
    timestamps()
  }

  parameters {
    choice(name: 'ENV', choices: ['dev', 'qa', 'prod'], description: 'Target environment (Terraform workspace & tfvars).')
    choice(name: 'ACTION', choices: ['plan', 'apply', 'destroy'], description: 'Terraform action to perform.')
    string(name: 'TF_DIR', defaultValue: 'infra', description: 'Relative path to Terraform root.')
    string(name: 'TF_VERSION', defaultValue: '1.7.5', description: 'Terraform version installed on the agent (or tool name).')
    booleanParam(name: 'REFRESH', defaultValue: true, description: 'Run plan with -refresh=true.')
    string(name: 'EXTRA_ARGS', defaultValue: '', description: 'Extra args to append to plan/apply/destroy (e.g., -target=module.foo).')
  }

  environment {
    // Example: AWS credentials ID, or use Azure/GCP blocks instead.
    // Replace with your Jenkins Credentials IDs.
    CLOUD_CREDS_ID = 'aws-prod-ro'   // Swap per your setup
    // Optional: Terraform tool installation if using Jenkins "Global Tool Configuration"
    // TF_TOOL = tool name: 'Terraform_1_7_5'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scmGit(branches: [[name: '*/master']], extensions: [], userRemoteConfigs: [[credentialsId: 'a51f1f5d-733a-435f-8d64-89c695a2b829', url: 'https://github.com/damiodutola/terraform-jenkins-pipeline']])
      }
    }

    stage('Setup Terraform') {
      steps {
        dir(params.TF_DIR) {
          sh """
            terraform -version || true
          """
          // Optional: validate fmt early
          sh """
            terraform fmt -check -recursive || true
            terraform init -input=false $( [ -f backend.hcl ] && echo "-backend-config=backend.hcl" )
          """
        }
      }
    }

    stage('Select/Create Workspace') {
      steps {
        dir(params.TF_DIR) {
          sh """
            terraform workspace list >/dev/null 2>&1 || terraform workspace new default || true
            terraform workspace select ${params.ENV} >/dev/null 2>&1 || terraform workspace new ${params.ENV}
            echo "Using workspace: $(terraform workspace show)"
          """
        }
      }
    }

    stage('Validate') {
      steps {
        dir(params.TF_DIR) {
          sh 'terraform validate -no-color'
        }
      }
    }

    stage('Plan') {
      when { anyOf { expression { params.ACTION == 'plan' }; expression { params.ACTION == 'apply' }; expression { params.ACTION == 'destroy' } } }
      steps {
        dir(params.TF_DIR) {
          script {
            def refresh = params.REFRESH ? "-refresh=true" : "-refresh=false"
            def tfvars = "vars/${params.ENV}.tfvars"
            def destroyFlag = (params.ACTION == 'destroy') ? "-destroy" : ""
            sh """
              terraform plan -no-color ${destroyFlag} \\
                -input=false \\
                ${refresh} \\
                -var-file=${tfvars} \\
                ${params.EXTRA_ARGS} \\
                -out=tfplan
            """
          }
        }
      }
      post {
        success {
          archiveArtifacts artifacts: "${params.TF_DIR}/tfplan", fingerprint: true
        }
      }
    }

    // --- Approval gates per environment ---
    stage('Approve DEV') {
      when { allOf { expression { params.ENV == 'dev' }; anyOf { expression { params.ACTION == 'apply' }; expression { params.ACTION == 'destroy' } } } }
      steps {
        script {
          timeout(time: 2, unit: 'HOURS') {
            def resp = input(
              id: 'DevApproval',
              message: "Approve ${params.ACTION.toUpperCase()} for DEV?",
              submitter: 'dev-approvers,team-leads', // Jenkins user/group names
              parameters: [
                string(name: 'CONFIRM', defaultValue: '', description: "Type dev to confirm."),
              ]
            )
            if (resp?.CONFIRM?.trim() != 'dev') {
              error "Confirmation failed. Expected 'dev'."
            }
          }
        }
      }
    }

    stage('Approve QA') {
      when { allOf { expression { params.ENV == 'qa' }; anyOf { expression { params.ACTION == 'apply' }; expression { params.ACTION == 'destroy' } } } }
      steps {
        script {
          timeout(time: 4, unit: 'HOURS') {
            def resp = input(
              id: 'QaApproval',
              message: "Approve ${params.ACTION.toUpperCase()} for QA?",
              submitter: 'qa-approvers,qa-leads',
              parameters: [
                string(name: 'CONFIRM', defaultValue: '', description: "Type qa to confirm."),
              ]
            )
            if (resp?.CONFIRM?.trim() != 'qa') {
              error "Confirmation failed. Expected 'qa'."
            }
          }
        }
      }
    }

    stage('Approve PROD') {
      when { allOf { expression { params.ENV == 'prod' }; anyOf { expression { params.ACTION == 'apply' }; expression { params.ACTION == 'destroy' } } } }
      steps {
        script {
          timeout(time: 24, unit: 'HOURS') {
            def resp = input(
              id: 'ProdApproval',
              message: "FINAL APPROVAL: ${params.ACTION.toUpperCase()} for PROD",
              submitter: 'prod-approvers,change-advisory-board', // tighten for prod
              parameters: [
                string(name: 'CHANGE_ID', defaultValue: '', description: 'Enter Change Request ID'),
                string(name: 'CONFIRM',    defaultValue: '', description: "Type prod to confirm."),
              ]
            )
            if (!resp?.CHANGE_ID?.trim()) { error "Change ID required for PROD." }
            if (resp?.CONFIRM?.trim() != 'prod') { error "Confirmation failed. Expected 'prod'." }
            currentBuild.displayName = "#${env.BUILD_NUMBER} ${params.ACTION.toUpperCase()} ${params.ENV} CR:${resp.CHANGE_ID}"
          }
        }
      }
    }

    // --- Apply / Destroy with per-env locking ---
    stage('Apply / Destroy') {
      when { anyOf { expression { params.ACTION == 'apply' }; expression { params.ACTION == 'destroy' } } }
      options { lock(resource: "tf-${params.ENV}", inversePrecedence: true) }
      steps {
        dir(params.TF_DIR) {
          withCredentials([
            // Example: AWS. Replace with your cloud credentials.
            [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.CLOUD_CREDS_ID]
          ]) {
            sh """
              # Use the saved plan (ensures what was reviewed is what gets applied)
              terraform apply -no-color -input=false tfplan
            """
          }
        }
      }
    }
  }

  post {
    always {
      dir(params.TF_DIR) {
        sh 'terraform workspace show || true'
      }
      cleanWs(cleanWhenAborted: true, deleteDirs: true)
    }
  }
}
